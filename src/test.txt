diff --git a/src/game.cpp b/src/game.cpp
index 0485f4e..aa56410 100644
--- a/src/game.cpp
+++ b/src/game.cpp
@@ -44,11 +44,22 @@
  *
  */
 
+// TODO(Justin) Collision based on whether or not the
+// player is shielded.
+
+// TODO(Justin): Getting the normal of the ship's side
+// that the asteroid makes contact with, I think, is
+// incorrect.
+
+// NOTE(Justin): Collisions have been colesced into the sat_collision
+// function. Not sure if this was a good idea.
+
 #include "game.h"
+#include "game_random.h"
 #include "game_render_group.h"
 #include "game_render_group.cpp"
+#include "game_entity.h"
 #include "game_string.cpp"
-#include "game_tile.cpp"
 #include "game_asset.cpp"
 
 #define White V3F(1.0f, 1.0f, 1.0f)
@@ -227,6 +238,20 @@ circle_support_point(circle *Circle, v2f Dir)
 	return(Result);
 }
 
+internal v2f
+circle_tangent(circle *Circle, v2f Dir)
+{
+	v2f Result = {};
+
+	v2f SupportPoint = circle_support_point(Circle, Dir);
+
+	v2f NormalAtSupport = SupportPoint + (SupportPoint - Circle->Center);
+
+	Result = v2f_normalize(v2f_perp(NormalAtSupport));
+
+	return(Result);
+}
+
 struct interval
 {
 	f32 min;
@@ -774,6 +799,52 @@ closest_point_to_circle(v2f *Vertices, u32 vertex_count, circle *Circle)
 	return(Result);
 }
 
+#if 0
+internal b32
+circles_collision(circle *CircleA, circle *CircleB)
+{
+	b32 GapExists = false;
+
+	v2f ProjectedAxis = v2f_normalize(CircleB->Center - CircleA->Center);
+
+	interval CircleAInterval = circle_project_onto_axis(CircleA, ProjectedAxis);
+	interval CircleBInterval = circle_project_onto_axis(CircleB, ProjectedAxis);
+
+	if(!((CircleAInterval.max >= CircleBInterval.min) &&
+		 (CircleBInterval.max >= CircleAInterval.min)))
+	{
+		return(GapExists);
+	}
+
+	ProjectedAxis = v2f_normalize(CircleA->Center - CircleB->Center);
+
+	CircleAInterval = circle_project_onto_axis(CircleA, ProjectedAxis);
+	CircleBInterval = circle_project_onto_axis(CircleB, ProjectedAxis);
+
+	if(!((CircleAInterval.max >= CircleBInterval.min) &&
+		 (CircleBInterval.max >= CircleAInterval.min)))
+	{
+		return(GapExists);
+	}
+	return(!GapExists);
+}
+#endif
+
+internal b32
+circles_collision(circle *CircleA, circle *CircleB)
+{
+	b32 Colliding = false;
+
+	f32 distance_between_centers = v2f_length(CircleA->Center - CircleB->Center);
+	f32 radii_sum = CircleA->radius + CircleB->radius;
+	if(distance_between_centers < radii_sum)
+	{
+		Colliding = true;
+	}
+
+	return(Colliding);
+}
+
 // TODO(Justin): Need to figure the shapes associated with the entities. ATM they
 // this only works in a special case and was implemented in this way as a step
 // towards the final game.
@@ -782,51 +853,76 @@ sat_collision(entity *EntityA, entity *EntityB)
 {
 	b32 GapExists = false;
 
-	circle Circle = circle_init(EntityB->Pos, EntityB->radius);
-	for(u32 vertex_i = 0; vertex_i < ARRAY_COUNT(EntityA->Poly.Vertices); vertex_i++)
+	if((EntityA->shape == SHAPE_CIRCLE) && (EntityB->shape == SHAPE_CIRCLE))
 	{
-		v2f P0 = EntityA->Poly.Vertices[vertex_i];
-		v2f P1 = EntityA->Poly.Vertices[(vertex_i + 1) % ARRAY_COUNT(EntityA->Poly.Vertices)];
-		v2f D = P1 - P0;
+		circle CircleA = circle_init(EntityA->Pos, EntityA->radius);
+		circle CircleB = circle_init(EntityB->Pos, EntityB->radius);
 
-		v2f ProjectedAxis = v2f_normalize(-1.0f * v2f_perp(D));
-
-		interval EntityAInterval = sat_projected_interval(EntityA->Poly.Vertices,
-															ARRAY_COUNT(EntityA->Poly.Vertices), ProjectedAxis);
-
-		interval EntityBInterval = circle_project_onto_axis(&Circle, ProjectedAxis);
+		//GapExists = circles_collision(&CircleA, &CircleB);
+		return(circles_collision(&CircleA, &CircleB));
+	}
+	else
+	{
+		entity *EntityWithPoly;
+		entity *EntityWithOutPoly;
 
-		if(EntityBInterval.min > EntityBInterval.max)
+		if(EntityA->shape == SHAPE_POLY)
+		{
+			EntityWithPoly = EntityA;
+			EntityWithOutPoly = EntityB;
+		}
+		else
 		{
-			f32 temp = EntityBInterval.min;
-			EntityBInterval.min = EntityBInterval.max;
-			EntityBInterval.max = temp;
+			EntityWithPoly = EntityB;
+			EntityWithOutPoly = EntityA;
 		}
 
-		if(!((EntityBInterval.max >= EntityAInterval.min) &&
-			 (EntityAInterval.max >= EntityBInterval.min)))
+		circle Circle = circle_init(EntityWithOutPoly->Pos, EntityWithOutPoly->radius);
+		for(u32 vertex_i = 0; vertex_i < ARRAY_COUNT(EntityWithPoly->Poly.Vertices); vertex_i++)
 		{
+			v2f P0 = EntityWithPoly->Poly.Vertices[vertex_i];
+			v2f P1 = EntityWithPoly->Poly.Vertices[(vertex_i + 1) % ARRAY_COUNT(EntityWithPoly->Poly.Vertices)];
+			v2f D = P1 - P0;
 
-			return(GapExists);
+			v2f ProjectedAxis = v2f_normalize(-1.0f * v2f_perp(D));
+
+			interval PolyInterval = sat_projected_interval(EntityWithPoly->Poly.Vertices,
+											   ARRAY_COUNT(EntityWithPoly->Poly.Vertices), ProjectedAxis);
+
+			interval CircleInterval = circle_project_onto_axis(&Circle, ProjectedAxis);
+
+			if(CircleInterval.min > CircleInterval.max)
+			{
+				f32 temp = CircleInterval.min;
+				CircleInterval.min = CircleInterval.max;
+				CircleInterval.max = temp;
+			}
+
+			if(!((CircleInterval.max >= PolyInterval.min) &&
+				 (PolyInterval.max >= CircleInterval.min)))
+			{
+
+				return(GapExists);
+			}
 		}
-	}
 
-	v2f ClosestPoint = closest_point_to_circle(EntityA->Poly.Vertices,
-															ARRAY_COUNT(EntityA->Poly.Vertices), &Circle);
+		v2f ClosestPoint = closest_point_to_circle(EntityWithPoly->Poly.Vertices,
+									   ARRAY_COUNT(EntityWithPoly->Poly.Vertices), &Circle);
 
-	v2f ProjectedAxis = v2f_normalize(ClosestPoint - Circle.Center);
+		v2f ProjectedAxis = v2f_normalize(ClosestPoint - Circle.Center);
 
-	interval EntityAInterval = sat_projected_interval(EntityA->Poly.Vertices,
-															ARRAY_COUNT(EntityA->Poly.Vertices), ProjectedAxis);
+		interval PolyInterval = sat_projected_interval(EntityWithPoly->Poly.Vertices,
+										   ARRAY_COUNT(EntityWithPoly->Poly.Vertices), ProjectedAxis);
 
-	interval EntityBInterval = circle_project_onto_axis(&Circle, ProjectedAxis);
+		interval CircleInterval = circle_project_onto_axis(&Circle, ProjectedAxis);
 
-	if(!((EntityBInterval.max >= EntityAInterval.min) &&
-		 (EntityAInterval.max >= EntityBInterval.min)))
-	{
-		return(GapExists);
-	}
+		if(!((CircleInterval.max >= PolyInterval.min) &&
+		     (PolyInterval.max >= CircleInterval.min)))
+		{
+			return(GapExists);
+		}
 
+	}
 	return(!GapExists);
 }
 
@@ -895,34 +991,7 @@ triangle_circle_collision(triangle *Triangle, circle *Circle)
 }
 #endif
 
-internal b32
-circles_collision(circle *CircleA, circle *CircleB)
-{
-	b32 GapExists = false;
 
-	v2f ProjectedAxis = v2f_normalize(CircleB->Center - CircleA->Center);
-
-	interval CircleAInterval = circle_project_onto_axis(CircleA, ProjectedAxis);
-	interval CircleBInterval = circle_project_onto_axis(CircleB, ProjectedAxis);
-
-	if(!((CircleAInterval.max >= CircleBInterval.min) &&
-		 (CircleBInterval.max >= CircleAInterval.min)))
-	{
-		return(GapExists);
-	}
-
-	ProjectedAxis = v2f_normalize(CircleA->Center - CircleB->Center);
-
-	CircleAInterval = circle_project_onto_axis(CircleA, ProjectedAxis);
-	CircleBInterval = circle_project_onto_axis(CircleB, ProjectedAxis);
-
-	if(!((CircleAInterval.max >= CircleBInterval.min) &&
-		 (CircleBInterval.max >= CircleAInterval.min)))
-	{
-		return(GapExists);
-	}
-	return(!GapExists);
-}
 
 inline entity *
 entity_get(game_state *GameState, u32 index)
@@ -944,10 +1013,10 @@ entity_add(game_state *GameState, entity_type type)
 	if(type == ENTITY_PROJECTILE)
 	{
 		b32 projectile_overwrite = false;
-		for(u32 i = 0; i < ARRAY_COUNT(GameState->Entities); i++)
+		for(u32 i = 1; i < ARRAY_COUNT(GameState->Entities); i++)
 		{
 			entity *Entity = GameState->Entities + i;
-			if((Entity->type == ENTITY_PROJECTILE) && (!Entity->exists))
+			if((Entity->type == ENTITY_PROJECTILE) && (entity_flag_is_set(Entity, ENTITY_FLAG_NON_SPATIAL)))
 			{
 				entity_index = i;
 				projectile_overwrite = true;
@@ -1027,14 +1096,6 @@ player_polygon_update(entity *EntityPlayer)
 	EntityPlayer->Poly.Vertices[6] = FrontRight;
 }
 
-struct move_spec
-{
-	b32 use_normalized_accel;
-	f32 speed;
-	f32 angular_speed;
-	f32 mass;
-};
-
 internal void
 entity_move(game_state *GameState, entity *Entity, v2f ddPos, f32 dt)
 { 
@@ -1070,57 +1131,42 @@ entity_move(game_state *GameState, entity *Entity, v2f ddPos, f32 dt)
 		EntityNewPos.y += 2.0f * World->Dim.y;
 	}
 
-	v2f NewVel = dt * ddPos + Entity->dPos;
+	v2f EntityNewVel = dt * ddPos + Entity->dPos;
 
 	f32 max_speed = 50.0f;
-	f32 dp_length_squared = v2f_length_squared(NewVel);
+	f32 dp_length_squared = v2f_length_squared(EntityNewVel);
 	if(dp_length_squared > 75.0f)
 	{
-		if(ABS(NewVel.x) > 50.0f)
+		if(ABS(EntityNewVel.x) > 50.0f)
 		{
-			NewVel.x *= ABS(1.0f / NewVel.x);
-			NewVel.x *= max_speed;
+			EntityNewVel.x *= ABS(1.0f / EntityNewVel.x);
+			EntityNewVel.x *= max_speed;
 		}
-		if(ABS(NewVel.y) > 50.0f)
+		if(ABS(EntityNewVel.y) > 50.0f)
 		{
-			NewVel.y *= ABS(1.0f / NewVel.y);
-			NewVel.y *= max_speed;
+			EntityNewVel.y *= ABS(1.0f / EntityNewVel.y);
+			EntityNewVel.y *= max_speed;
 		}
 	}
 
-	Entity->dPos = NewVel;
-
-	// TODO(Justin): If an entity cannot be collided with, the collision
-	// detection should be completely skipped.
-
-
-	// TODO(Justin): Does the entity collide? No? Then skip collision detection.
 	v2f Normal = {};
-	u32 entity_hit_index  = 0;
-	for(u32 entity_index = 1; entity_index < GameState->entity_count; entity_index++)
+	entity *HitEntity = 0;
+	if(entity_flag_is_set(Entity, ENTITY_FLAG_COLLIDES))
 	{
-		entity *TestEntity = entity_get(GameState, entity_index);
-
-		if(TestEntity->collides)
+		for(u32 entity_index = 1; entity_index < GameState->entity_count; entity_index++)
 		{
-			if(!entities_are_same(Entity, TestEntity))
+			entity *TestEntity = entity_get(GameState, entity_index);
+			if(Entity != TestEntity)
 			{
-				if(Entity->type == ENTITY_ASTEROID)
+				if(entity_flag_is_set(TestEntity, ENTITY_FLAG_COLLIDES))
 				{
-					if(TestEntity->type == ENTITY_PLAYER)
-					{
-						// TODO(Jusitn): Right now the order of the entites
-						// passed to the sat_collision function matters. Fix
-						// this.
-
-						// TODO(Justin) Collision based on whether or not the
-						// player is shielded.
-
-						// TODO(Justin): Getting the normal of the ship's side
-						// that the asteroid makes contact with, I think, is
-						// incorrect.
-
-						if(sat_collision(TestEntity, Entity))
+					if(sat_collision(TestEntity, Entity))
+					{ 
+						if((Entity->shape == SHAPE_CIRCLE) && (TestEntity->shape == SHAPE_CIRCLE))
+						{
+							Normal = v2f_normalize(TestEntity->Pos - Entity->Pos);
+						}
+						else
 						{
 							v2f Delta = TestEntity->Pos - Entity->Pos;
 							for(u32 vertex_i = 0; vertex_i < ARRAY_COUNT(TestEntity->Poly.Vertices); vertex_i++)
@@ -1137,37 +1183,23 @@ entity_move(game_state *GameState, entity *Entity, v2f ddPos, f32 dt)
 									break;
 								}
 							}
-							entity_hit_index = TestEntity->index;
 						}
+						HitEntity = TestEntity;
 					}
-					else if(TestEntity->type == ENTITY_ASTEROID)
-					{
-						circle EntityCircle = circle_init(Entity->Pos, Entity->radius);
-						circle TestEntityCircle = circle_init(TestEntity->Pos, TestEntity->radius);
-						if(circles_collision(&EntityCircle, &TestEntityCircle))
-						{
-							Normal = v2f_normalize(EntityCircle.Center - TestEntityCircle.Center);
-							entity_hit_index = TestEntity->index;
-						}
-					}
-				}
-				else if(Entity->type == ENTITY_PLAYER)
-				{
 				}
 			}
 		}
 	}
 
-	if(entity_hit_index)
-	{
-		entity *HitEntity = entity_get(GameState, entity_hit_index);
 
+	if(HitEntity)
+	{
 		if(Entity->type == ENTITY_PLAYER)
 		{
 			if(!Entity->is_shielded)
 			{
-				Entity->Pos = V2F(0.0f, 0.0f);
-				Entity->dPos = {};
+				EntityNewPos = V2F(0.0f, 0.0f);
+				EntityNewVel = {};
 				Entity->is_shielded = true;
 			}
 			else
@@ -1177,25 +1209,45 @@ entity_move(game_state *GameState, entity *Entity, v2f ddPos, f32 dt)
 				{
 					Entity->is_shielded = false;
 				}
-				Entity->dPos = Entity->dPos - 2.0f * v2f_dot(Entity->dPos, Normal) * Normal;
+				EntityNewVel = Entity->dPos - 2.0f * v2f_dot(Entity->dPos, Normal) * Normal;
 			}
-
-			//TODO(Justin): Not sure if this sshould be updated exactly here.
-			//But it nedds to be updated after the pl
-			//create one on the fly whenever we need to do collision testing
-
 		}
 		else if(Entity->type == ENTITY_ASTEROID)
 		{
-			Entity->dPos = Entity->speed * Normal;
+			if(HitEntity->type == ENTITY_ASTEROID)
+			{
+				v2f Tangent = v2f_perp(Normal);
+
+				f32 EntitydY = v2f_dot(Tangent, Entity->dPos);
+				f32 EntitydX = v2f_dot(Normal, Entity->dPos);
+#if 1
+				f32 HitEntitydY = v2f_dot(Tangent, HitEntity->dPos);
+				f32 HitEntitydX = v2f_dot(Normal, HitEntity->dPos);
+
+				f32 total_mass = Entity->mass + HitEntity->mass;
+
+				EntitydX = (EntitydX * (Entity->mass - HitEntity->mass) + 2.0f * HitEntity->mass * HitEntitydX) / total_mass;
 
-			// TODO(Justin): Asteroids also have hit points ranging from 1
-			// to 3. If the asteroid hitpoint goes to 0 then the asteroid is
-			// destroyed.
-			//
-			// TODO(Justin): Asteroids can collide with the player, other
-			// asteroids and projectiles. Each of these situations has different
-			// result.
+				//Entity->dPos = EntitydY * Tangent + EntitydX * Normal;
+				EntityNewVel = EntitydY * Tangent + EntitydX * Normal;
+
+				f32 spread = Entity->radius + HitEntity->radius - v2f_length(Entity->Pos - HitEntity->Pos);
+				Entity->Pos += spread * Normal;
+#endif
+				//Entity->dPos = Entity->speed * Normal;
+
+				// TODO(Justin): Asteroids also have hit points ranging from 1
+				// to 3. If the asteroid hitpoint goes to 0 then the asteroid is
+				// destroyed.
+				//
+				// TODO(Justin): Asteroids can collide with the player, other
+				// asteroids and projectiles. Each of these situations has different
+				// result.
+			}
+			else
+			{
+				EntityNewVel = Entity->speed * Normal;
+			}
 		}
 		else if(Entity->type == ENTITY_PROJECTILE)
 		{
@@ -1204,22 +1256,20 @@ entity_move(game_state *GameState, entity *Entity, v2f ddPos, f32 dt)
 		}
 		else if(Entity->type == ENTITY_CIRCLE)
 		{
-			//Entity->dPos = Entity->dPos - 2.0f * v2f_dot(Entity->dPos, Normal) * Normal;
 			Entity->dPos = Entity->speed * Normal;
-			//entity *EntityHit = entity_get(GameState, entity_hit_index);
 		}
 	}
 
 	Entity->Pos = EntityNewPos;
+	Entity->dPos = EntityNewVel;
 
 	if(Entity->type == ENTITY_PLAYER)
 	{
 		player_polygon_update(Entity);
 	}
-
-	// TODO(Justin): Updating Bounding Box/Poly after moving the entity
 }
 
+
 internal triangle
 triangle_init(v2f *Vertices, u32 vertex_count)
 {
@@ -1268,12 +1318,12 @@ player_add(game_state *GameState)
 	entity *Entity = entity_add(GameState, ENTITY_PLAYER);
 
 	Entity->exists = true;
-	Entity->collides = true;
+
+	entity_flag_set(Entity, ENTITY_FLAG_COLLIDES);
 	Entity->is_shooting = false;
 	Entity->is_warping = false;
 	Entity->is_shielded = true;
 
-	//Entity->height = 20.0f;
 	Entity->height = 18.0f;
 	Entity->base_half_width = 15.0f;
 
@@ -1285,18 +1335,13 @@ player_add(game_state *GameState)
 	Entity->hit_point_max = 3;
 	Entity->HitPoints.count = Entity->hit_point_max;
 
-	Entity->shape = SHAPE_TRIANGLE;
+	Entity->shape = SHAPE_POLY;
 
 	// NOTE(Justin): This is not a vertex but used for calculating vertices.
 	// Vertices are also stored in CCW order which is requried.
 	v2f FrontCenter = Entity->Pos + Entity->height * Entity->Direction;
-	// Front left
 	v2f FrontLeft = FrontCenter + -1.5f * Entity->Right;
-
-	// Front right
 	v2f FrontRight = FrontCenter + 1.5f * Entity->Right;
-
-	// Back center
 	v2f BackCenter = Entity->Pos - 0.5f * Entity->height * Entity->Direction;
 
 	v2f Right = Entity->Pos + 0.75f * Entity->base_half_width * Entity->Right;
@@ -1304,7 +1349,6 @@ player_add(game_state *GameState)
 
 	v2f RearLeftEngine = Left -1.0f * Entity->height * Entity->Direction;
 	v2f RearRightEngine = Right - 1.0f * Entity->height * Entity->Direction;
-
 	v2f SideLeftEngine = BackCenter -1.0f * Entity->base_half_width * Entity->Right;
 	v2f SideRightEngine = BackCenter + 1.0f * Entity->base_half_width * Entity->Right;
 
@@ -1319,57 +1363,78 @@ player_add(game_state *GameState)
 	return(Entity);
 }
 
-inline f32
-f32_rand_percent(void)
+
+internal entity *
+asteroid_add(game_state *GameState, asteroid_size SIZE, v2f Pos, v2f Dir, f32 speed)
 {
-	f32 Result = 0.0f;
 
-	Result = ((f32)rand() / (f32)RAND_MAX);
+	entity *Entity = entity_add(GameState, ENTITY_ASTEROID);
 
-	return(Result);
-}
+	Entity->exists = true;
+	entity_flag_set(Entity, ENTITY_FLAG_COLLIDES);
 
-inline f32
-f32_rand(f32 min, f32 max)
-{
-	f32 Result = 0.0f;
+	random_sequence Sequence = seed(2023);
+	f32 speed_scale = f32_rand_percent();
 
-	Result = min + (f32_rand_percent()) * (max - min);
+	Entity->Direction = Dir;
+	Entity->speed = 19.0f;
 
-	return(Result);
-}
+	//f32 asteroid_speed = speed_scale * Entity->speed;
+	f32 asteroid_speed = speed;
 
-inline v2f
-v2f_rand(f32 min, f32 max)
-{
-	v2f Result = {};
+	// TODO(Justin): Make sure that asteroids cannot spwan on top of the player
+	world *World = GameState->World;
+	Entity->Pos = Pos;
+	Entity->dPos = Entity->speed * Entity->Direction;
 
-	f32 x = f32_rand(min, max);
-	f32 y = f32_rand(min, max);
+	// TODO(Jusitn): Rand scaling, orientation, size, and mass.
 
-	Result = V2F(x, y);
+	// TODO(Jusitn): ALL the radii are the same for testing collisions
+	Entity->shape = SHAPE_CIRCLE;
 
-	return(Result);
+	if(SIZE == ASTEROID_SMALL)
+	{
+		Entity->radius = 8.0f;
+		Entity->mass = Entity->radius * 10.0f;
+	}
+
+	if(SIZE == ASTEROID_MEDIUM)
+	{
+		Entity->radius = 8.0f;
+		Entity->mass = Entity->radius * 20.0f;
+	}
+
+	if(SIZE == ASTEROID_LARGE)
+	{
+		Entity->radius = 8.0f;
+		Entity->mass = Entity->radius * 40.0f;
+	}
+
+	//Entity->mass = Entity->radius * 10.0f;
+
+	return(Entity);
 }
 
 internal entity *
 asteroid_add(game_state *GameState, asteroid_size SIZE)
 {
+
 	entity *Entity = entity_add(GameState, ENTITY_ASTEROID);
 
 	Entity->exists = true;
-	Entity->collides = true;
+	entity_flag_set(Entity, ENTITY_FLAG_COLLIDES);
 
-	f32 speed_scale = ((f32)rand() / (f32)RAND_MAX);
+	random_sequence Sequence = seed(2023);
+	f32 speed_scale = f32_rand_percent();
 
-	Entity->Direction = v2f_normalize(V2F(f32_rand(-1.0f, 1.0f), f32_rand(-1.0f, 1.0f)));
+	Entity->Direction = v2f_normalize(V2F(f32_rand_between(-1.0f, 1.0f), f32_rand_between(-1.0f, 1.0f)));
 	Entity->speed = 19.0f;
 
 	f32 asteroid_speed = speed_scale * Entity->speed;
 
 	// TODO(Justin): Make sure that asteroids cannot spwan on top of the player
 	world *World = GameState->World;
-	Entity->Pos = V2F(f32_rand(-World->Dim.x, World->Dim.x), f32_rand(-World->Dim.y, World->Dim.y));
+	Entity->Pos = V2F(f32_rand_between(-World->Dim.x, World->Dim.x), f32_rand_between(-World->Dim.y, World->Dim.y));
 
 	Entity->dPos = asteroid_speed * Entity->Direction;
 
@@ -1382,6 +1447,8 @@ asteroid_add(game_state *GameState, asteroid_size SIZE)
 		Entity->radius = 8.0f;
 	}
 
+	Entity->mass = Entity->radius * 10.0f;
+
 	return(Entity);
 }
 
@@ -1401,7 +1468,7 @@ familiar_add(game_state *GameState)
 	entity *Entity = entity_add(GameState, ENTITY_FAMILIAR);
 
 	Entity->exists = true;
-	Entity->collides = true;
+	entity_flag_set(Entity, ENTITY_FLAG_COLLIDES);
 
 	Entity->speed = 1.0f;
 
@@ -1411,14 +1478,10 @@ familiar_add(game_state *GameState)
 internal entity *
 projectile_add(game_state *GameState)
 {
-	// TODO(Justin): Maybe need a separate array of entities specifically
-	// for projectiles. We can sort the arrray by whether or not the projectile
-	// is used or not used. If it is not used it is safe to overwrite the
-	// projectile
 	entity *Entity = entity_add(GameState, ENTITY_PROJECTILE);
 
 	Entity->exists = true;
-	Entity->collides = true;
+	entity_flag_set(Entity, ENTITY_FLAG_COLLIDES);
 
 	entity *EntityPlayer = GameState->Entities + GameState->player_entity_index;
 
@@ -1432,18 +1495,23 @@ projectile_add(game_state *GameState)
 	return(Entity);
 }
 
+#if 0
 internal entity *
 triangle_add(game_state *GameState)
 {
 	entity *Entity = entity_add(GameState, ENTITY_TRIANGLE);
 
 	Entity->exists = true;
-	Entity->collides = true;
+	entity_flag_set(Entity, ENTITY_FLAG_COLLIDES);
+	//Entity->collides = true;
 
 	world *World = GameState->World;
 
-	Entity->Pos = v2f_rand(f32_rand(-World->Dim.x, World->Dim.x), f32_rand(World->Dim.y, World->Dim.y));
-	Entity->Direction = v2f_normalize(V2F(f32_rand(-1.0f, 1.0f), f32_rand(-1.0f, 1.0f)));
+	Entity->Pos = V2F(f32_rand_between(-World->Dim.x, World->Dim.x),
+					  f32_rand_between(World->Dim.y, World->Dim.y));
+
+	Entity->Direction = v2f_normalize(V2F(f32_rand_between(-1.0f, 1.0f),
+										  f32_rand_between(-1.0f, 1.0f)));
 	Entity->speed = 10.0f;
 	Entity->dPos = Entity->speed * Entity->Direction;
 
@@ -1455,6 +1523,8 @@ triangle_add(game_state *GameState)
 
 	return(Entity);
 }
+#endif
+
 
 internal entity *
 circle_add(game_state *GameState, v2f Pos, v2f Dir)
@@ -1462,7 +1532,7 @@ circle_add(game_state *GameState, v2f Pos, v2f Dir)
 	entity *Entity = entity_add(GameState, ENTITY_CIRCLE);
 
 	Entity->exists = true;
-	Entity->collides = true;
+	entity_flag_set(Entity, ENTITY_FLAG_COLLIDES);
 
 	world *World = GameState->World;
 
@@ -1485,7 +1555,7 @@ square_add(game_state *GameState, v2f Pos, v2f Dir)
 	entity *Entity = entity_add(GameState, ENTITY_SQUARE);
 
 	Entity->exists = true;
-	Entity->collides = true;
+	entity_flag_set(Entity, ENTITY_FLAG_COLLIDES);
 
 	world *World = GameState->World;
 
@@ -1500,7 +1570,6 @@ square_add(game_state *GameState, v2f Pos, v2f Dir)
 	return(Entity);
 }
 
-
 internal void
 square_draw(back_buffer *BackBuffer, v2f Pos, f32 half_width, v3f Color)
 {
@@ -1518,13 +1587,31 @@ square_draw(back_buffer *BackBuffer, v2f Pos, f32 half_width, v3f Color)
 }
 
 inline void
-push_piece(entity_visible_piece_group *PieceGroup, loaded_bitmap *Bitmap, v2f Offset, v2f Align, f32 alpha = 1.0f)
+push_piece(entity_visible_piece_group *PieceGroup, loaded_bitmap *Bitmap,
+		v2f Pos, v2f Align, v2f Dim, v4f Color)
 {
 	ASSERT(PieceGroup->piece_count < ARRAY_COUNT(PieceGroup->Pieces));
 	entity_visible_piece *Piece = PieceGroup->Pieces + PieceGroup->piece_count++;
 	Piece->Bitmap = Bitmap;
-	Piece->Offset = Offset - Align;
-	Piece->alpha = alpha;
+	Piece->Pos = Pos - Align;
+	Piece->r = Color.r;
+	Piece->g = Color.g;
+	Piece->b = Color.b;
+	Piece->alpha = Color.a;
+	Piece->Dim = Dim;
+}
+
+inline void
+push_bitmap(entity_visible_piece_group *PieceGroup, loaded_bitmap *Bitmap,
+		v2f Pos, v2f Align, f32 alpha = 1.0f)
+{
+	push_piece(PieceGroup, Bitmap, Pos, Align, V2F(0, 0), V4F(1.0f, 1.0f, 1.0f, alpha));
+}
+
+inline void
+push_rectangle(entity_visible_piece_group *PieceGroup, v2f Pos, v2f Dim, v4f Color)
+{
+	push_piece(PieceGroup, 0, Pos, V2F(0, 0), Dim, Color);
 }
 
 internal void
@@ -1545,8 +1632,6 @@ triangle_draw(back_buffer *BackBuffer, triangle *Triangle, v3f Color)
 	triangle_draw(BackBuffer, Triangle, Color.r, Color.g, Color.b);
 }
 
-
-
 internal void
 familiar_update(game_state *GameState, entity *Entity, f32 dt)
 {
@@ -1589,28 +1674,18 @@ projectile_update(game_state *GameState, entity *Entity, f32 dt)
 {
 	ASSERT(Entity->type == ENTITY_PROJECTILE);
 
-	v2f DeltaPos = dt * Entity->dPos;
-	Entity->distance_remaining -= v2f_length(DeltaPos);
-	if(Entity->distance_remaining > 0.0f)
-	{
-		v2f ddPos = {};
-		entity_move(GameState, Entity, ddPos, dt);
-	}
-	else
+	//v2f DeltaPos = dt * Entity->dPos;
+	v2f OldPos = Entity->Pos;
+	v2f ddPos = {};
+	entity_move(GameState, Entity, ddPos, dt);
+	f32 distance_traveled = v2f_length(Entity->Pos - OldPos);
+	Entity->distance_remaining -= distance_traveled;
+	if(Entity->distance_remaining < 0.0f)
 	{
-		// TODO(Justin): Remove from entity set? Or just overwrite it? 
-		Entity->exists = false;
-		GameState->entity_count--;
+		entity_flag_set(Entity, ENTITY_FLAG_NON_SPATIAL);
 	}
 }
 
-struct basis
-{
-	v2f Origin;
-	v2f XAxis;
-	v2f YAxis;
-};
-
 internal v2f
 v2f_world_to_screen(game_state *GameState, v2f BottomLeft, v2f Pos)
 {
@@ -1633,6 +1708,7 @@ v2f_screen_to_world(game_state *GameState, v2f ScreenXY)
 	return(Result);
 }
 
+
 internal void
 player_polygon_draw(back_buffer *BackBuffer, game_state *GameState, v2f BottomLeft, entity *EntityPlayer)
 {
@@ -1645,13 +1721,12 @@ player_polygon_draw(back_buffer *BackBuffer, game_state *GameState, v2f BottomLe
 	v2f FrontRight = EntityPlayer->Poly.Vertices[6];
 
 	v2f ScreenPos = v2f_world_to_screen(GameState, BottomLeft, EntityPlayer->Pos);
+
 	v2f ScreenBackCenter = v2f_world_to_screen(GameState, BottomLeft, BackCenter);
 	v2f ScreenFrontLeft = v2f_world_to_screen(GameState, BottomLeft, FrontLeft);
 	v2f ScreenFrontRight = v2f_world_to_screen(GameState, BottomLeft, FrontRight);
-
 	v2f ScreenRearLeftEngine = v2f_world_to_screen(GameState, BottomLeft, RearLeftEngine);
 	v2f ScreenRearRightEngine = v2f_world_to_screen(GameState, BottomLeft, RearRightEngine);
-
 	v2f ScreenSideLeftEngine = v2f_world_to_screen(GameState, BottomLeft, SideLeftEngine);
 	v2f ScreenSideRightEngine = v2f_world_to_screen(GameState, BottomLeft, SideRightEngine);
 
@@ -1680,19 +1755,25 @@ update_and_render(game_memory *GameMemory, back_buffer *BackBuffer, sound_buffer
 
 		//GameState->TestSound = wav_file_read_entire("sfx/bloop_00.wav");
 		GameState->Background = bitmap_file_read_entire("space_background.bmp");
+
 		GameState->Ship = bitmap_file_read_entire("ship/blueships1_up.bmp");
 
-		GameState->WarpFrames[0] = bitmap_file_read_entire("vfx/warp_01.bmp");
-		GameState->WarpFrames[1] = bitmap_file_read_entire("vfx/warp_02.bmp");
-		GameState->WarpFrames[2] = bitmap_file_read_entire("vfx/warp_03.bmp");
-		GameState->WarpFrames[3] = bitmap_file_read_entire("vfx/warp_04.bmp");
-		GameState->WarpFrames[4] = bitmap_file_read_entire("vfx/warp_05.bmp");
-		GameState->WarpFrames[5] = bitmap_file_read_entire("vfx/warp_06.bmp");
-		GameState->WarpFrames[6] = bitmap_file_read_entire("vfx/warp_07.bmp");
-		GameState->WarpFrames[7] = bitmap_file_read_entire("vfx/warp_08.bmp");
+		// NOTE(Justin): Since there is not a ground in the game all the
+		// bitmaps, most likely, will be drawn at the center of the object. In
+		// order to center the bitmap at the point we just need to subtract off
+		// half the width and half the height of the bitmap position and it will
+		// be centered at the objects position.
+
+		loaded_bitmap *ShipBitmap = &GameState->Ship;
+		ShipBitmap->Align = V2F((f32)ShipBitmap->width / 2.0f, (f32)ShipBitmap->height / 2.0f);
 
-		GameState->AsteroidSprite = bitmap_file_read_entire("asteroids/01.bmp");
-		GameState->LaserBlue = bitmap_file_read_entire("lasers/laser_small_blue.bmp");
+		GameState->AsteroidBitmap = bitmap_file_read_entire("asteroids/01.bmp");
+		loaded_bitmap *AsteroidBitmap = &GameState->AsteroidBitmap;
+		AsteroidBitmap->Align = V2F((f32)AsteroidBitmap->width / 2.0f, (f32)AsteroidBitmap->height / 2.0f);
+
+		GameState->LaserBlueBitmap = bitmap_file_read_entire("lasers/laser_small_blue.bmp");
+		loaded_bitmap *LaserBlueBitmap = &GameState->LaserBlueBitmap;
+		LaserBlueBitmap->Align = V2F((f32)LaserBlueBitmap->width / 2.0f, (f32)LaserBlueBitmap->height / 2.0f);
 
 		memory_arena_initialize(&GameState->WorldArena, GameMemory->total_size - sizeof(game_state),
 				(u8 *)GameMemory->permanent_storage + sizeof(game_state));
@@ -1707,9 +1788,16 @@ update_and_render(game_memory *GameMemory, back_buffer *BackBuffer, sound_buffer
 		entity *EntityPlayer = player_add(GameState);
 		GameState->player_entity_index = EntityPlayer->index;
 
+
 		srand(2023);
 
 		// TODO(Justin): This size of the asteroid should be random.
+		//f32 speed = 19.0f;
+		//asteroid_add(GameState, ASTEROID_SMALL, V2F(-100.0f, -100.0f), V2F(1.0f, 1.0f), speed);
+		//asteroid_add(GameState, ASTEROID_MEDIUM, V2F(-50.0f, -50.0f), V2F(-1.0f, -1.0f), 2.0f * speed);
+		//
+
+		asteroid_add(GameState, ASTEROID_SMALL);
 		asteroid_add(GameState, ASTEROID_SMALL);
 		asteroid_add(GameState, ASTEROID_SMALL);
 		asteroid_add(GameState, ASTEROID_SMALL);
@@ -1719,6 +1807,9 @@ update_and_render(game_memory *GameMemory, back_buffer *BackBuffer, sound_buffer
 		asteroid_add(GameState, ASTEROID_SMALL);
 		asteroid_add(GameState, ASTEROID_SMALL);
 		asteroid_add(GameState, ASTEROID_SMALL);
+		asteroid_add(GameState, ASTEROID_SMALL);
+		asteroid_add(GameState, ASTEROID_SMALL);
+
 		asteroid_add(GameState, ASTEROID_SMALL);
 		asteroid_add(GameState, ASTEROID_SMALL);
 		asteroid_add(GameState, ASTEROID_SMALL);
@@ -1726,10 +1817,6 @@ update_and_render(game_memory *GameMemory, back_buffer *BackBuffer, sound_buffer
 		asteroid_add(GameState, ASTEROID_SMALL);
 		asteroid_add(GameState, ASTEROID_SMALL);
 
-		for(u32 i = 0; i < ARRAY_COUNT(GameState->Squares); i++)
-		{
-			GameState->Squares[i].half_width = 5.0f;
-		}
 
 
 		GameMemory->is_initialized = true;
@@ -1823,12 +1910,11 @@ update_and_render(game_memory *GameMemory, back_buffer *BackBuffer, sound_buffer
 			{
 				v2f PlayerPos = Entity->Pos;
 				v2f ScreenPos = v2f_world_to_screen(GameState, BottomLeft, PlayerPos);
-				v2f Alignment = {(f32)GameState->Ship.width / 2.0f, (f32)GameState->Ship.height / 2.0f};
-
-				push_piece(&PieceGroup, &GameState->Ship, ScreenPos, Alignment);
 
+				push_bitmap(&PieceGroup, &GameState->Ship, ScreenPos, GameState->Ship.Align);
 #if 1
 				player_polygon_draw(BackBuffer, GameState, BottomLeft, Entity);
+#if 1
 				if(Entity->is_shielded)
 				{
 					circle Circle = circle_init(Entity->Pos, Entity->height);
@@ -1838,15 +1924,15 @@ update_and_render(game_memory *GameMemory, back_buffer *BackBuffer, sound_buffer
 					circle_draw(BackBuffer, &Circle, White);
 
 				}
+#endif
 #endif
 			} break;
 			case ENTITY_ASTEROID:
 			{
 				v2f AsteroidPos = Entity->Pos;
 				v2f ScreenPos = v2f_world_to_screen(GameState, BottomLeft, AsteroidPos);
-				v2f Alignment = {(f32)GameState->AsteroidSprite.width / 2.0f, (f32)GameState->AsteroidSprite.height / 2.0f};
 
-				push_piece(&PieceGroup, &GameState->AsteroidSprite, ScreenPos, Alignment);
+				push_bitmap(&PieceGroup, &GameState->AsteroidBitmap, ScreenPos, GameState->AsteroidBitmap.Align);
 
 #if 0
 				v2f temp = v2f_normalize(Entity->dPos);
@@ -1860,27 +1946,26 @@ update_and_render(game_memory *GameMemory, back_buffer *BackBuffer, sound_buffer
 				//v2f AsteroidScreenPos = tile_map_get_screen_coordinates(TileMap, &Entity->TileMapPos,
 				//		BottomLeft, tile_side_in_pixels, meters_to_pixels);
 				//debug_vector_draw_at_point(BackBuffer, AsteroidScreenPos, Entity->Direction);
-				//v2f Alignment = {(f32)GameState->AsteroidSprite.width / 2.0f,
-				//				 (f32)GameState->AsteroidSprite.height / 2.0f};
+				//v2f Alignment = {(f32)GameState->AsteroidBitmap.width / 2.0f,
+				//				 (f32)GameState->AsteroidBitmap.height / 2.0f};
 
-				//push_piece(&PieceGroup, &GameState->AsteroidSprite, AsteroidScreenPos, Alignment);
+				//push_piece(&PieceGroup, &GameState->AsteroidBitmap, AsteroidScreenPos, Alignment);
 
 			} break;
 			case ENTITY_PROJECTILE:
 			{
-				// NOTE(Justin): This is a hack.
 				projectile_update(GameState, Entity, dt);
-				if(Entity->exists)
+				if(!entity_flag_is_set(Entity, ENTITY_FLAG_NON_SPATIAL))
 				{
 					v2f LaserPos = Entity->Pos;
 					v2f ScreenPos = v2f_world_to_screen(GameState, BottomLeft, LaserPos);
-					v2f Alignment = {(f32)GameState->LaserBlue.width / 2.0f, (f32)GameState->LaserBlue.height / 2.0f};
 
-					push_piece(&PieceGroup, &GameState->LaserBlue, ScreenPos, Alignment);
+					push_bitmap(&PieceGroup, &GameState->LaserBlueBitmap, ScreenPos, GameState->LaserBlueBitmap.Align);
 				}
 			} break;
 			case ENTITY_TRIANGLE:
 			{
+#if 0
 				v2f Pos = Entity->Pos;
 				entity_move(GameState, Entity, Entity->dPos, dt);
 				v2f NewPos = Entity->Pos;
@@ -1891,6 +1976,7 @@ update_and_render(game_memory *GameMemory, back_buffer *BackBuffer, sound_buffer
 					Entity->TriangleHitBox.Vertices[i] += Delta;
 				}
 				triangle_draw(BackBuffer, &Entity->TriangleHitBox, White);
+#endif
 
 			} break;
 			case ENTITY_CIRCLE:
@@ -1915,10 +2001,10 @@ update_and_render(game_memory *GameMemory, back_buffer *BackBuffer, sound_buffer
 
 		for(u32 piece_index = 0; piece_index < PieceGroup.piece_count; piece_index++)
 		{
-			entity_visible_piece *Piece = &PieceGroup.Pieces[piece_index];
+			entity_visible_piece *Piece = PieceGroup.Pieces + piece_index;
 
-			f32 x = Piece->Offset.x;
-			f32 y = Piece->Offset.y;
+			f32 x = Piece->Pos.x;
+			f32 y = Piece->Pos.y;
 
 			if(Piece->Bitmap)
 			{
@@ -1926,6 +2012,8 @@ update_and_render(game_memory *GameMemory, back_buffer *BackBuffer, sound_buffer
 			}
 			else
 			{
+				//v2f HalfDim = 0.5f * GameState->pixels_per_meter * Piece->Dim;
+				//rectangle_draw(BackBuffer, Min , v2f Max, Piece->r, Piece->g, Piece->b, Piece->alpha);
 			}
 		}
 	}
